---
output: github_document
bibliography: references.bib
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# culturalEvolution

<!-- badges: start -->

<!-- badges: end -->

**`culturalEvolution`** provides a set of convenient functions for models of cultural evolution and/or diffusion processes.

## Installation

You can install the development version of **`culturalEvolution`** from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("acastroaraujo/culturalEvolution")
```

Currently available functions:

-   `recursion()`

-   `multi_par_call()`

## Recursion

```{r setup}
library(culturalEvolution)
```

You can construct *any* model with the `recursion()` function and a mathematical expression.

Each of these models is a *new* function of class "rfun." Each of these new functions has the same arguments:

-   `params` a list of parameters that match those in the mathematical expression

-   `q_init` the initial value for the proportion of the "cultural trait."

-   `tn` the number of time periods.

Here are two very simple models from @henrich2001:

```{r recursion-example}

env_learn <- recursion(
  expr = q + (1 - q)*P1 - q*P2
)

env_learn ## special print

out <- env_learn(
  params = list(P1 = 0.308, P2 = 0.062), 
  tn = 100
)

str(out)

plot(out, type = "l")

biased_transmission <- recursion(
  expr = q + q*(1 - q)*B
)

biased_transmission ## special print

out <- biased_transmission(
  params = list(B = 0.1), 
  q_init = 0.005,  ## q cannot start as zero in this model!
  tn = 100
)

plot(out, type = "l")

```

*Errors:*

Every recursive function will check that the supplied list of parameters corresponds to the mathematical expression.

```{r, error=TRUE}
out <- biased_transmission(
  params = list(X = 0.1)
)
```

`q` and `t` cannot be supplied as a parameters:

```{r, error=TRUE}
out <- env_learn(
  params = list(q = 0.01)
)

out <- env_learn(
  params = list(t = 1)
)
```

**Using lists of parameters**

The `multi_par_call()` allows us to pass lists of parameters in the form of data frames (i.e., one combination per row).

Here we create a similar graph to Figure 11 in @henrich2001 [pp. 1006]:

```{r multi-par-example}
comb_mod <- recursion(
  expr = q + 0.5*(P1 + (L-1)*q) + 0.5*q*(1-q)*(b*(1 - a) + a*(2*q - 1))
)

grid <- tidyr::crossing(
  a = seq(0, 0.4, length.out = 100),
  b = 0.2, 
  L = 0.98, 
  P1 = 0.012
)

out <- multi_par_call(grid, comb_mod, q_init = 0, tn = 200)

str(out)

library(ggplot2)

out |> 
  ggplot(aes(t, q, group = .id, color = a)) + 
  geom_line() + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "grey50") +
  labs(color = "alpha") + 
  scale_color_viridis_c(option = "H") +
  theme_bw() 

```

## References
